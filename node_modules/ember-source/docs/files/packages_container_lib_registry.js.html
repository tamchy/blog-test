<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>packages/container/lib/registry.js - The Ember API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="The Ember API" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: v2.11.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Backburner.html">Backburner</a></li>
                                <li><a href="../classes/BucketCache.html">BucketCache</a></li>
                                <li><a href="../classes/Container.html">Container</a></li>
                                <li><a href="../classes/ContainerProxyMixin.html">ContainerProxyMixin</a></li>
                                <li><a href="../classes/Descriptor.html">Descriptor</a></li>
                                <li><a href="../classes/Ember.html">Ember</a></li>
                                <li><a href="../classes/Ember.ActionHandler.html">Ember.ActionHandler</a></li>
                                <li><a href="../classes/Ember.ActionSupport.html">Ember.ActionSupport</a></li>
                                <li><a href="../classes/Ember.Application.html">Ember.Application</a></li>
                                <li><a href="../classes/Ember.ApplicationInstance.html">Ember.ApplicationInstance</a></li>
                                <li><a href="../classes/Ember.ApplicationInstance.BootOptions.html">Ember.ApplicationInstance.BootOptions</a></li>
                                <li><a href="../classes/Ember.Array.html">Ember.Array</a></li>
                                <li><a href="../classes/Ember.ArrayProxy.html">Ember.ArrayProxy</a></li>
                                <li><a href="../classes/Ember.AutoLocation.html">Ember.AutoLocation</a></li>
                                <li><a href="../classes/Ember.Binding.html">Ember.Binding</a></li>
                                <li><a href="../classes/Ember.Checkbox.html">Ember.Checkbox</a></li>
                                <li><a href="../classes/Ember.ClassNamesSupport.html">Ember.ClassNamesSupport</a></li>
                                <li><a href="../classes/Ember.Comparable.html">Ember.Comparable</a></li>
                                <li><a href="../classes/Ember.Component.html">Ember.Component</a></li>
                                <li><a href="../classes/Ember.computed.html">Ember.computed</a></li>
                                <li><a href="../classes/Ember.ComputedProperty.html">Ember.ComputedProperty</a></li>
                                <li><a href="../classes/Ember.ContainerDebugAdapter.html">Ember.ContainerDebugAdapter</a></li>
                                <li><a href="../classes/Ember.Controller.html">Ember.Controller</a></li>
                                <li><a href="../classes/Ember.ControllerMixin.html">Ember.ControllerMixin</a></li>
                                <li><a href="../classes/Ember.Copyable.html">Ember.Copyable</a></li>
                                <li><a href="../classes/Ember.CoreObject.html">Ember.CoreObject</a></li>
                                <li><a href="../classes/Ember.CoreView.html">Ember.CoreView</a></li>
                                <li><a href="../classes/Ember.DataAdapter.html">Ember.DataAdapter</a></li>
                                <li><a href="../classes/Ember.Debug.html">Ember.Debug</a></li>
                                <li><a href="../classes/Ember.DefaultResolver.html">Ember.DefaultResolver</a></li>
                                <li><a href="../classes/Ember.EachProxy.html">Ember.EachProxy</a></li>
                                <li><a href="../classes/Ember.Engine.html">Ember.Engine</a></li>
                                <li><a href="../classes/Ember.EngineInstance.html">Ember.EngineInstance</a></li>
                                <li><a href="../classes/Ember.Enumerable.html">Ember.Enumerable</a></li>
                                <li><a href="../classes/Ember.Error.html">Ember.Error</a></li>
                                <li><a href="../classes/Ember.EventDispatcher.html">Ember.EventDispatcher</a></li>
                                <li><a href="../classes/Ember.Evented.html">Ember.Evented</a></li>
                                <li><a href="../classes/Ember.FEATURES.html">Ember.FEATURES</a></li>
                                <li><a href="../classes/Ember.Freezable.html">Ember.Freezable</a></li>
                                <li><a href="../classes/Ember.HashLocation.html">Ember.HashLocation</a></li>
                                <li><a href="../classes/Ember.Helper.html">Ember.Helper</a></li>
                                <li><a href="../classes/Ember.HistoryLocation.html">Ember.HistoryLocation</a></li>
                                <li><a href="../classes/Ember.HTMLBars.html">Ember.HTMLBars</a></li>
                                <li><a href="../classes/Ember.inject.html">Ember.inject</a></li>
                                <li><a href="../classes/Ember.InjectedProperty.html">Ember.InjectedProperty</a></li>
                                <li><a href="../classes/Ember.Instrumentation.html">Ember.Instrumentation</a></li>
                                <li><a href="../classes/Ember.LinkComponent.html">Ember.LinkComponent</a></li>
                                <li><a href="../classes/Ember.Location.html">Ember.Location</a></li>
                                <li><a href="../classes/Ember.Map.html">Ember.Map</a></li>
                                <li><a href="../classes/Ember.MapWithDefault.html">Ember.MapWithDefault</a></li>
                                <li><a href="../classes/Ember.Mixin.html">Ember.Mixin</a></li>
                                <li><a href="../classes/Ember.MutableArray.html">Ember.MutableArray</a></li>
                                <li><a href="../classes/Ember.MutableEnumerable.html">Ember.MutableEnumerable</a></li>
                                <li><a href="../classes/Ember.Namespace.html">Ember.Namespace</a></li>
                                <li><a href="../classes/Ember.NativeArray.html">Ember.NativeArray</a></li>
                                <li><a href="../classes/Ember.NoneLocation.html">Ember.NoneLocation</a></li>
                                <li><a href="../classes/Ember.Object.html">Ember.Object</a></li>
                                <li><a href="../classes/Ember.ObjectProxy.html">Ember.ObjectProxy</a></li>
                                <li><a href="../classes/Ember.Observable.html">Ember.Observable</a></li>
                                <li><a href="../classes/Ember.OrderedSet.html">Ember.OrderedSet</a></li>
                                <li><a href="../classes/Ember.PromiseProxyMixin.html">Ember.PromiseProxyMixin</a></li>
                                <li><a href="../classes/Ember.ProxyMixin.html">Ember.ProxyMixin</a></li>
                                <li><a href="../classes/Ember.Route.html">Ember.Route</a></li>
                                <li><a href="../classes/Ember.Router.html">Ember.Router</a></li>
                                <li><a href="../classes/Ember.run.html">Ember.run</a></li>
                                <li><a href="../classes/Ember.Service.html">Ember.Service</a></li>
                                <li><a href="../classes/Ember.String.html">Ember.String</a></li>
                                <li><a href="../classes/Ember.TargetActionSupport.html">Ember.TargetActionSupport</a></li>
                                <li><a href="../classes/Ember.Templates.helpers.html">Ember.Templates.helpers</a></li>
                                <li><a href="../classes/Ember.Test.html">Ember.Test</a></li>
                                <li><a href="../classes/Ember.Test.Adapter.html">Ember.Test.Adapter</a></li>
                                <li><a href="../classes/Ember.Test.QUnitAdapter.html">Ember.Test.QUnitAdapter</a></li>
                                <li><a href="../classes/Ember.TextArea.html">Ember.TextArea</a></li>
                                <li><a href="../classes/Ember.TextField.html">Ember.TextField</a></li>
                                <li><a href="../classes/Ember.TextSupport.html">Ember.TextSupport</a></li>
                                <li><a href="../classes/Ember.View.html">Ember.View</a></li>
                                <li><a href="../classes/Ember.ViewMixin.html">Ember.ViewMixin</a></li>
                                <li><a href="../classes/Function.html">Function</a></li>
                                <li><a href="../classes/Libraries.html">Libraries</a></li>
                                <li><a href="../classes/Registry.html">Registry</a></li>
                                <li><a href="../classes/RegistryProxyMixin.html">RegistryProxyMixin</a></li>
                                <li><a href="../classes/RoutingService.html">RoutingService</a></li>
                                <li><a href="../classes/String.html">String</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/ember.html">ember</a></li>
                                <li><a href="../modules/ember-application.html">ember-application</a></li>
                                <li><a href="../modules/ember-debug.html">ember-debug</a></li>
                                <li><a href="../modules/ember-extension-support.html">ember-extension-support</a></li>
                                <li><a href="../modules/ember-glimmer.html">ember-glimmer</a></li>
                                <li><a href="../modules/ember-htmlbars.html">ember-htmlbars</a></li>
                                <li><a href="../modules/ember-metal.html">ember-metal</a></li>
                                <li><a href="../modules/ember-routing.html">ember-routing</a></li>
                                <li><a href="../modules/ember-runtime.html">ember-runtime</a></li>
                                <li><a href="../modules/ember-testing.html">ember-testing</a></li>
                                <li><a href="../modules/ember-views.html">ember-views</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: packages/container/lib/registry.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import { dictionary, EmptyObject, assign, intern } from &#x27;ember-utils&#x27;;
import { assert, deprecate } from &#x27;ember-metal&#x27;;
import Container from &#x27;./container&#x27;;

const VALID_FULL_NAME_REGEXP = /^[^:]+:[^:]+$/;

/**
 A registry used to store factory and option information keyed
 by type.

 A &#x60;Registry&#x60; stores the factory and option information needed by a
 &#x60;Container&#x60; to instantiate and cache objects.

 The API for &#x60;Registry&#x60; is still in flux and should not be considered stable.

 @private
 @class Registry
 @since 1.11.0
*/
export default function Registry(options) {
  this.fallback = options &amp;&amp; options.fallback ? options.fallback : null;

  if (options &amp;&amp; options.resolver) {
    this.resolver = options.resolver;

    if (typeof this.resolver === &#x27;function&#x27;) {
      deprecateResolverFunction(this);
    }
  }

  this.registrations  = dictionary(options &amp;&amp; options.registrations ? options.registrations : null);

  this._typeInjections        = dictionary(null);
  this._injections            = dictionary(null);
  this._factoryTypeInjections = dictionary(null);
  this._factoryInjections     = dictionary(null);

  this._localLookupCache      = new EmptyObject();
  this._normalizeCache        = dictionary(null);
  this._resolveCache          = dictionary(null);
  this._failCache             = dictionary(null);

  this._options               = dictionary(null);
  this._typeOptions           = dictionary(null);
}

Registry.prototype = {
  /**
   A backup registry for resolving registrations when no matches can be found.

   @private
   @property fallback
   @type Registry
   */
  fallback: null,

  /**
   An object that has a &#x60;resolve&#x60; method that resolves a name.

   @private
   @property resolver
   @type Resolver
   */
  resolver: null,

  /**
   @private
   @property registrations
   @type InheritingDict
   */
  registrations: null,

  /**
   @private

   @property _typeInjections
   @type InheritingDict
   */
  _typeInjections: null,

  /**
   @private

   @property _injections
   @type InheritingDict
   */
  _injections: null,

  /**
   @private

   @property _factoryTypeInjections
   @type InheritingDict
   */
  _factoryTypeInjections: null,

  /**
   @private

   @property _factoryInjections
   @type InheritingDict
   */
  _factoryInjections: null,

  /**
   @private

   @property _normalizeCache
   @type InheritingDict
   */
  _normalizeCache: null,

  /**
   @private

   @property _resolveCache
   @type InheritingDict
   */
  _resolveCache: null,

  /**
   @private

   @property _options
   @type InheritingDict
   */
  _options: null,

  /**
   @private

   @property _typeOptions
   @type InheritingDict
   */
  _typeOptions: null,

  /**
   Creates a container based on this registry.

   @private
   @method container
   @param {Object} options
   @return {Container} created container
   */
  container(options) {
    return new Container(this, options);
  },

  /**
   Registers a factory for later injection.

   Example:

   &#x60;&#x60;&#x60;javascript
   let registry = new Registry();

   registry.register(&#x27;model:user&#x27;, Person, {singleton: false });
   registry.register(&#x27;fruit:favorite&#x27;, Orange);
   registry.register(&#x27;communication:main&#x27;, Email, {singleton: false});
   &#x60;&#x60;&#x60;

   @private
   @method register
   @param {String} fullName
   @param {Function} factory
   @param {Object} options
   */
  register(fullName, factory, options = {}) {
    assert(&#x27;fullName must be a proper full name&#x27;, this.validateFullName(fullName));

    if (factory === undefined) {
      throw new TypeError(&#x60;Attempting to register an unknown factory: &#x27;${fullName}&#x27;&#x60;);
    }

    let normalizedName = this.normalize(fullName);

    if (this._resolveCache[normalizedName]) {
      throw new Error(&#x60;Cannot re-register: &#x27;${fullName}&#x27;, as it has already been resolved.&#x60;);
    }

    delete this._failCache[normalizedName];
    this.registrations[normalizedName] = factory;
    this._options[normalizedName] = options;
  },

  /**
   Unregister a fullName

   &#x60;&#x60;&#x60;javascript
   let registry = new Registry();
   registry.register(&#x27;model:user&#x27;, User);

   registry.resolve(&#x27;model:user&#x27;).create() instanceof User //=&gt; true

   registry.unregister(&#x27;model:user&#x27;)
   registry.resolve(&#x27;model:user&#x27;) === undefined //=&gt; true
   &#x60;&#x60;&#x60;

   @private
   @method unregister
   @param {String} fullName
   */
  unregister(fullName) {
    assert(&#x27;fullName must be a proper full name&#x27;, this.validateFullName(fullName));

    let normalizedName = this.normalize(fullName);

    this._localLookupCache = new EmptyObject();

    delete this.registrations[normalizedName];
    delete this._resolveCache[normalizedName];
    delete this._failCache[normalizedName];
    delete this._options[normalizedName];
  },

  /**
   Given a fullName return the corresponding factory.

   By default &#x60;resolve&#x60; will retrieve the factory from
   the registry.

   &#x60;&#x60;&#x60;javascript
   let registry = new Registry();
   registry.register(&#x27;api:twitter&#x27;, Twitter);

   registry.resolve(&#x27;api:twitter&#x27;) // =&gt; Twitter
   &#x60;&#x60;&#x60;

   Optionally the registry can be provided with a custom resolver.
   If provided, &#x60;resolve&#x60; will first provide the custom resolver
   the opportunity to resolve the fullName, otherwise it will fallback
   to the registry.

   &#x60;&#x60;&#x60;javascript
   let registry = new Registry();
   registry.resolver = function(fullName) {
      // lookup via the module system of choice
    };

   // the twitter factory is added to the module system
   registry.resolve(&#x27;api:twitter&#x27;) // =&gt; Twitter
   &#x60;&#x60;&#x60;

   @private
   @method resolve
   @param {String} fullName
   @param {Object} [options]
   @param {String} [options.source] the fullname of the request source (used for local lookups)
   @return {Function} fullName&#x27;s factory
   */
  resolve(fullName, options) {
    assert(&#x27;fullName must be a proper full name&#x27;, this.validateFullName(fullName));
    let factory = resolve(this, this.normalize(fullName), options);
    if (factory === undefined &amp;&amp; this.fallback) {
      factory = this.fallback.resolve(...arguments);
    }
    return factory;
  },

  /**
   A hook that can be used to describe how the resolver will
   attempt to find the factory.

   For example, the default Ember &#x60;.describe&#x60; returns the full
   class name (including namespace) where Ember&#x27;s resolver expects
   to find the &#x60;fullName&#x60;.

   @private
   @method describe
   @param {String} fullName
   @return {string} described fullName
   */
  describe(fullName) {
    if (this.resolver &amp;&amp; this.resolver.lookupDescription) {
      return this.resolver.lookupDescription(fullName);
    } else if (this.fallback) {
      return this.fallback.describe(fullName);
    } else {
      return fullName;
    }
  },

  /**
   A hook to enable custom fullName normalization behaviour

   @private
   @method normalizeFullName
   @param {String} fullName
   @return {string} normalized fullName
   */
  normalizeFullName(fullName) {
    if (this.resolver &amp;&amp; this.resolver.normalize) {
      return this.resolver.normalize(fullName);
    } else if (this.fallback) {
      return this.fallback.normalizeFullName(fullName);
    } else {
      return fullName;
    }
  },

  /**
   Normalize a fullName based on the application&#x27;s conventions

   @private
   @method normalize
   @param {String} fullName
   @return {string} normalized fullName
   */
  normalize(fullName) {
    return this._normalizeCache[fullName] || (
        (this._normalizeCache[fullName] = this.normalizeFullName(fullName))
      );
  },

  /**
   @method makeToString

   @private
   @param {any} factory
   @param {string} fullName
   @return {function} toString function
   */
  makeToString(factory, fullName) {
    if (this.resolver &amp;&amp; this.resolver.makeToString) {
      return this.resolver.makeToString(factory, fullName);
    } else if (this.fallback) {
      return this.fallback.makeToString(factory, fullName);
    } else {
      return factory.toString();
    }
  },

  /**
   Given a fullName check if the container is aware of its factory
   or singleton instance.

   @private
   @method has
   @param {String} fullName
   @param {Object} [options]
   @param {String} [options.source] the fullname of the request source (used for local lookups)
   @return {Boolean}
   */
  has(fullName, options) {
    if (!this.isValidFullName(fullName)) {
      return false;
    }

    let source = options &amp;&amp; options.source &amp;&amp; this.normalize(options.source);

    return has(this, this.normalize(fullName), source);
  },

  /**
   Allow registering options for all factories of a type.

   &#x60;&#x60;&#x60;javascript
   let registry = new Registry();
   let container = registry.container();

   // if all of type &#x60;connection&#x60; must not be singletons
   registry.optionsForType(&#x27;connection&#x27;, { singleton: false });

   registry.register(&#x27;connection:twitter&#x27;, TwitterConnection);
   registry.register(&#x27;connection:facebook&#x27;, FacebookConnection);

   let twitter = container.lookup(&#x27;connection:twitter&#x27;);
   let twitter2 = container.lookup(&#x27;connection:twitter&#x27;);

   twitter === twitter2; // =&gt; false

   let facebook = container.lookup(&#x27;connection:facebook&#x27;);
   let facebook2 = container.lookup(&#x27;connection:facebook&#x27;);

   facebook === facebook2; // =&gt; false
   &#x60;&#x60;&#x60;

   @private
   @method optionsForType
   @param {String} type
   @param {Object} options
   */
  optionsForType(type, options) {
    this._typeOptions[type] = options;
  },

  getOptionsForType(type) {
    let optionsForType = this._typeOptions[type];
    if (optionsForType === undefined &amp;&amp; this.fallback) {
      optionsForType = this.fallback.getOptionsForType(type);
    }
    return optionsForType;
  },

  /**
   @private
   @method options
   @param {String} fullName
   @param {Object} options
   */
  options(fullName, options = {}) {
    let normalizedName = this.normalize(fullName);
    this._options[normalizedName] = options;
  },

  getOptions(fullName) {
    let normalizedName = this.normalize(fullName);
    let options = this._options[normalizedName];

    if (options === undefined &amp;&amp; this.fallback) {
      options = this.fallback.getOptions(fullName);
    }
    return options;
  },

  getOption(fullName, optionName) {
    let options = this._options[fullName];

    if (options &amp;&amp; options[optionName] !== undefined) {
      return options[optionName];
    }

    let type = fullName.split(&#x27;:&#x27;)[0];
    options = this._typeOptions[type];

    if (options &amp;&amp; options[optionName] !== undefined) {
      return options[optionName];
    } else if (this.fallback) {
      return this.fallback.getOption(fullName, optionName);
    }
  },

  /**
   Used only via &#x60;injection&#x60;.

   Provides a specialized form of injection, specifically enabling
   all objects of one type to be injected with a reference to another
   object.

   For example, provided each object of type &#x60;controller&#x60; needed a &#x60;router&#x60;.
   one would do the following:

   &#x60;&#x60;&#x60;javascript
   let registry = new Registry();
   let container = registry.container();

   registry.register(&#x27;router:main&#x27;, Router);
   registry.register(&#x27;controller:user&#x27;, UserController);
   registry.register(&#x27;controller:post&#x27;, PostController);

   registry.typeInjection(&#x27;controller&#x27;, &#x27;router&#x27;, &#x27;router:main&#x27;);

   let user = container.lookup(&#x27;controller:user&#x27;);
   let post = container.lookup(&#x27;controller:post&#x27;);

   user.router instanceof Router; //=&gt; true
   post.router instanceof Router; //=&gt; true

   // both controllers share the same router
   user.router === post.router; //=&gt; true
   &#x60;&#x60;&#x60;

   @private
   @method typeInjection
   @param {String} type
   @param {String} property
   @param {String} fullName
   */
  typeInjection(type, property, fullName) {
    assert(&#x27;fullName must be a proper full name&#x27;, this.validateFullName(fullName));

    let fullNameType = fullName.split(&#x27;:&#x27;)[0];
    if (fullNameType === type) {
      throw new Error(&#x60;Cannot inject a &#x27;${fullName}&#x27; on other ${type}(s).&#x60;);
    }

    let injections = this._typeInjections[type] ||
                     (this._typeInjections[type] = []);

    injections.push({
      property: property,
      fullName: fullName
    });
  },

  /**
   Defines injection rules.

   These rules are used to inject dependencies onto objects when they
   are instantiated.

   Two forms of injections are possible:

   * Injecting one fullName on another fullName
   * Injecting one fullName on a type

   Example:

   &#x60;&#x60;&#x60;javascript
   let registry = new Registry();
   let container = registry.container();

   registry.register(&#x27;source:main&#x27;, Source);
   registry.register(&#x27;model:user&#x27;, User);
   registry.register(&#x27;model:post&#x27;, Post);

   // injecting one fullName on another fullName
   // eg. each user model gets a post model
   registry.injection(&#x27;model:user&#x27;, &#x27;post&#x27;, &#x27;model:post&#x27;);

   // injecting one fullName on another type
   registry.injection(&#x27;model&#x27;, &#x27;source&#x27;, &#x27;source:main&#x27;);

   let user = container.lookup(&#x27;model:user&#x27;);
   let post = container.lookup(&#x27;model:post&#x27;);

   user.source instanceof Source; //=&gt; true
   post.source instanceof Source; //=&gt; true

   user.post instanceof Post; //=&gt; true

   // and both models share the same source
   user.source === post.source; //=&gt; true
   &#x60;&#x60;&#x60;

   @private
   @method injection
   @param {String} factoryName
   @param {String} property
   @param {String} injectionName
   */
  injection(fullName, property, injectionName) {
    this.validateFullName(injectionName);
    let normalizedInjectionName = this.normalize(injectionName);

    if (fullName.indexOf(&#x27;:&#x27;) === -1) {
      return this.typeInjection(fullName, property, normalizedInjectionName);
    }

    assert(&#x27;fullName must be a proper full name&#x27;, this.validateFullName(fullName));
    let normalizedName = this.normalize(fullName);

    let injections = this._injections[normalizedName] ||
                     (this._injections[normalizedName] = []);

    injections.push({
      property: property,
      fullName: normalizedInjectionName
    });
  },


  /**
   Used only via &#x60;factoryInjection&#x60;.

   Provides a specialized form of injection, specifically enabling
   all factory of one type to be injected with a reference to another
   object.

   For example, provided each factory of type &#x60;model&#x60; needed a &#x60;store&#x60;.
   one would do the following:

   &#x60;&#x60;&#x60;javascript
   let registry = new Registry();

   registry.register(&#x27;store:main&#x27;, SomeStore);

   registry.factoryTypeInjection(&#x27;model&#x27;, &#x27;store&#x27;, &#x27;store:main&#x27;);

   let store = registry.lookup(&#x27;store:main&#x27;);
   let UserFactory = registry.lookupFactory(&#x27;model:user&#x27;);

   UserFactory.store instanceof SomeStore; //=&gt; true
   &#x60;&#x60;&#x60;

   @private
   @method factoryTypeInjection
   @param {String} type
   @param {String} property
   @param {String} fullName
   */
  factoryTypeInjection(type, property, fullName) {
    let injections = this._factoryTypeInjections[type] ||
                     (this._factoryTypeInjections[type] = []);

    injections.push({
      property: property,
      fullName: this.normalize(fullName)
    });
  },

  /**
   Defines factory injection rules.

   Similar to regular injection rules, but are run against factories, via
   &#x60;Registry#lookupFactory&#x60;.

   These rules are used to inject objects onto factories when they
   are looked up.

   Two forms of injections are possible:

   * Injecting one fullName on another fullName
   * Injecting one fullName on a type

   Example:

   &#x60;&#x60;&#x60;javascript
   let registry = new Registry();
   let container = registry.container();

   registry.register(&#x27;store:main&#x27;, Store);
   registry.register(&#x27;store:secondary&#x27;, OtherStore);
   registry.register(&#x27;model:user&#x27;, User);
   registry.register(&#x27;model:post&#x27;, Post);

   // injecting one fullName on another type
   registry.factoryInjection(&#x27;model&#x27;, &#x27;store&#x27;, &#x27;store:main&#x27;);

   // injecting one fullName on another fullName
   registry.factoryInjection(&#x27;model:post&#x27;, &#x27;secondaryStore&#x27;, &#x27;store:secondary&#x27;);

   let UserFactory = container.lookupFactory(&#x27;model:user&#x27;);
   let PostFactory = container.lookupFactory(&#x27;model:post&#x27;);
   let store = container.lookup(&#x27;store:main&#x27;);

   UserFactory.store instanceof Store; //=&gt; true
   UserFactory.secondaryStore instanceof OtherStore; //=&gt; false

   PostFactory.store instanceof Store; //=&gt; true
   PostFactory.secondaryStore instanceof OtherStore; //=&gt; true

   // and both models share the same source instance
   UserFactory.store === PostFactory.store; //=&gt; true
   &#x60;&#x60;&#x60;

   @private
   @method factoryInjection
   @param {String} factoryName
   @param {String} property
   @param {String} injectionName
   */
  factoryInjection(fullName, property, injectionName) {
    let normalizedName = this.normalize(fullName);
    let normalizedInjectionName = this.normalize(injectionName);

    this.validateFullName(injectionName);

    if (fullName.indexOf(&#x27;:&#x27;) === -1) {
      return this.factoryTypeInjection(normalizedName, property, normalizedInjectionName);
    }

    let injections = this._factoryInjections[normalizedName] || (this._factoryInjections[normalizedName] = []);

    injections.push({
      property: property,
      fullName: normalizedInjectionName
    });
  },

  /**
   @private
   @method knownForType
   @param {String} type the type to iterate over
  */
  knownForType(type) {
    let fallbackKnown, resolverKnown;

    let localKnown = dictionary(null);
    let registeredNames = Object.keys(this.registrations);
    for (let index = 0; index &lt; registeredNames.length; index++) {
      let fullName = registeredNames[index];
      let itemType = fullName.split(&#x27;:&#x27;)[0];

      if (itemType === type) {
        localKnown[fullName] = true;
      }
    }

    if (this.fallback) {
      fallbackKnown = this.fallback.knownForType(type);
    }

    if (this.resolver &amp;&amp; this.resolver.knownForType) {
      resolverKnown = this.resolver.knownForType(type);
    }

    return assign({}, fallbackKnown, localKnown, resolverKnown);
  },

  validateFullName(fullName) {
    if (!this.isValidFullName(fullName)) {
      throw new TypeError(&#x60;Invalid Fullname, expected: &#x27;type:name&#x27; got: ${fullName}&#x60;);
    }

    return true;
  },

  isValidFullName(fullName) {
    return !!VALID_FULL_NAME_REGEXP.test(fullName);
  },

  validateInjections(injections) {
    if (!injections) { return; }

    let fullName;

    for (let i = 0; i &lt; injections.length; i++) {
      fullName = injections[i].fullName;

      if (!this.has(fullName)) {
        throw new Error(&#x60;Attempting to inject an unknown injection: &#x27;${fullName}&#x27;&#x60;);
      }
    }
  },

  normalizeInjectionsHash(hash) {
    let injections = [];

    for (let key in hash) {
      if (hash.hasOwnProperty(key)) {
        assert(&#x60;Expected a proper full name, given &#x27;${hash[key]}&#x27;&#x60;, this.validateFullName(hash[key]));

        injections.push({
          property: key,
          fullName: hash[key]
        });
      }
    }

    return injections;
  },

  getInjections(fullName) {
    let injections = this._injections[fullName] || [];
    if (this.fallback) {
      injections = injections.concat(this.fallback.getInjections(fullName));
    }
    return injections;
  },

  getTypeInjections(type) {
    let injections = this._typeInjections[type] || [];
    if (this.fallback) {
      injections = injections.concat(this.fallback.getTypeInjections(type));
    }
    return injections;
  },

  getFactoryInjections(fullName) {
    let injections = this._factoryInjections[fullName] || [];
    if (this.fallback) {
      injections = injections.concat(this.fallback.getFactoryInjections(fullName));
    }
    return injections;
  },

  getFactoryTypeInjections(type) {
    let injections = this._factoryTypeInjections[type] || [];
    if (this.fallback) {
      injections = injections.concat(this.fallback.getFactoryTypeInjections(type));
    }
    return injections;
  }
};

function deprecateResolverFunction(registry) {
  deprecate(&#x27;Passing a &#x60;resolver&#x60; function into a Registry is deprecated. Please pass in a Resolver object with a &#x60;resolve&#x60; method.&#x27;,
            false,
            { id: &#x27;ember-application.registry-resolver-as-function&#x27;, until: &#x27;3.0.0&#x27;, url: &#x27;http://emberjs.com/deprecations/v2.x#toc_registry-resolver-as-function&#x27; });
  registry.resolver = {
    resolve: registry.resolver
  };
}

/**
 Given a fullName and a source fullName returns the fully resolved
 fullName. Used to allow for local lookup.

 &#x60;&#x60;&#x60;javascript
 let registry = new Registry();

 // the twitter factory is added to the module system
 registry.expandLocalLookup(&#x27;component:post-title&#x27;, { source: &#x27;template:post&#x27; }) // =&gt; component:post/post-title
 &#x60;&#x60;&#x60;

 @private
 @method expandLocalLookup
 @param {String} fullName
 @param {Object} [options]
 @param {String} [options.source] the fullname of the request source (used for local lookups)
 @return {String} fullName
 */
Registry.prototype.expandLocalLookup = function Registry_expandLocalLookup(fullName, options) {
  if (this.resolver &amp;&amp; this.resolver.expandLocalLookup) {
    assert(&#x27;fullName must be a proper full name&#x27;, this.validateFullName(fullName));
    assert(&#x27;options.source must be provided to expandLocalLookup&#x27;, options &amp;&amp; options.source);
    assert(&#x27;options.source must be a proper full name&#x27;, this.validateFullName(options.source));

    let normalizedFullName = this.normalize(fullName);
    let normalizedSource = this.normalize(options.source);

    return expandLocalLookup(this, normalizedFullName, normalizedSource);
  } else if (this.fallback) {
    return this.fallback.expandLocalLookup(fullName, options);
  } else {
    return null;
  }
};

function expandLocalLookup(registry, normalizedName, normalizedSource) {
  let cache = registry._localLookupCache;
  let normalizedNameCache = cache[normalizedName];

  if (!normalizedNameCache) {
    normalizedNameCache = cache[normalizedName] = new EmptyObject();
  }

  let cached = normalizedNameCache[normalizedSource];

  if (cached !== undefined) { return cached; }

  let expanded = registry.resolver.expandLocalLookup(normalizedName, normalizedSource);

  return normalizedNameCache[normalizedSource] = expanded;
}

function resolve(registry, normalizedName, options) {
  if (options &amp;&amp; options.source) {
    // when &#x60;source&#x60; is provided expand normalizedName
    // and source into the full normalizedName
    normalizedName = registry.expandLocalLookup(normalizedName, options);

    // if expandLocalLookup returns falsey, we do not support local lookup
    if (!normalizedName) { return; }
  }

  let cached = registry._resolveCache[normalizedName];
  if (cached !== undefined) { return cached; }
  if (registry._failCache[normalizedName]) { return; }

  let resolved;

  if (registry.resolver) {
    resolved = registry.resolver.resolve(normalizedName);
  }

  if (resolved === undefined) {
    resolved = registry.registrations[normalizedName];
  }

  if (resolved === undefined) {
    registry._failCache[normalizedName] = true;
  } else {
    registry._resolveCache[normalizedName] = resolved;
  }

  return resolved;
}

function has(registry, fullName, source) {
  return registry.resolve(fullName, { source }) !== undefined;
}

const privateNames = dictionary(null);
const privateSuffix = &#x60;${Math.random()}${Date.now()}&#x60;;

export function privatize([fullName]) {
  let name = privateNames[fullName];
  if (name) { return name; }

  let [type, rawName] = fullName.split(&#x27;:&#x27;);
  return privateNames[fullName] = intern(&#x60;${type}:${rawName}-${privateSuffix}&#x60;);
}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
